\chapter{Wayland Philosophy}
\label{ch:wayland-philosophy}

\epigraph{Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.}{--- Antoine de Saint-Exupéry}

\section{Introduction}

Every successful software project is built on a foundation of principles—explicit or implicit beliefs about what matters, what problems need solving, and how the solution should work. X11 had its principles: network transparency, mechanism-not-policy, extensibility. These served well for decades but ultimately constrained its evolution.

Wayland represents a fresh start, guided by lessons learned from X11's successes and failures. Understanding Wayland's philosophy is crucial because it explains not just \textit{what} Wayland is, but \textit{why} it's designed the way it is.

This chapter explores the core philosophical principles that guide Wayland's design. These aren't just abstract ideals—they're practical decisions that shape every aspect of the protocol, from how buffers are passed to how input events are routed.

\section{The Core Insight: The Compositor Is the Display Server}

\subsection{Recognizing Reality}

The single most important philosophical shift in Wayland is recognizing what modern display servers actually do.

In 2008, when Wayland development began, a typical Linux desktop looked like this:

\begin{enumerate}
    \item Applications render to windows
    \item X server manages those windows
    \item A compositor (Compiz, Mutter, KWin) intercepts everything
    \item The compositor re-renders all windows with effects
    \item The compositor sends the result back to the X server
    \item The X server displays it
\end{enumerate}

Notice something? The compositor is doing the actual display server work. It's:
\begin{itemize}
    \item Compositing all window content
    \item Applying effects and transformations
    \item Determining what appears on screen
    \item Managing the final displayed image
\end{itemize}

The X server has become a middleman, adding latency and complexity without adding value.

\begin{designbox}
\textbf{Wayland's First Principle}

\textit{Don't fight reality. If compositors are doing the display server's job, make the compositor the display server.}

This isn't just optimization—it's architectural honesty. The system does what it appears to do. There's no hidden layer adding complexity.
\end{designbox}

\subsection{Eliminating the Middleman}

In Wayland:
\begin{enumerate}
    \item Applications render to buffers
    \item Applications send buffers to the compositor
    \item The compositor composites and displays
\end{enumerate}

Three steps instead of six. No redundant components. Direct, clear flow.

This simplification isn't just about performance (though it helps). It's about conceptual clarity. When you understand the Wayland model, you understand what actually happens.

\section{Simplicity as a Core Value}

\subsection{The Complexity Tax}

X11's history demonstrates the cost of complexity:

\begin{itemize}
    \item Dozens of extensions, each adding state and edge cases
    \item Hundreds of thousands of lines of code
    \item Interactions between features that nobody fully understands
    \item Security holes that can't be fixed without breaking compatibility
    \item Performance optimizations fighting against the architecture
\end{itemize}

Each piece of complexity is a tax on every future change. Add enough complexity and the system becomes essentially unmaintainable.

\subsection{Wayland's Minimalism}

Wayland's core philosophy: \textbf{Include only what's necessary. Leave everything else out.}

This manifests in several ways:

\paragraph{Small Core Protocol}
The core Wayland protocol is remarkably small—just a handful of interfaces defining the essential communication between clients and compositors. Compare this to X11's massive core protocol.

\begin{notebox}
The Wayland protocol specification is about 10,000 lines. The X11 protocol specification is over 350,000 lines. This isn't just a size difference—it's a philosophical difference.
\end{notebox}

\paragraph{No Window Management in Core}
Wayland's core doesn't specify how windows are managed, positioned, or decorated. This seems like a glaring omission until you realize: different compositors need different window management.

A desktop environment needs:
\begin{itemize}
    \item Floating windows
    \item Maximize/minimize
    \item Window decorations
    \item Taskbars
\end{itemize}

A tiling window manager needs:
\begin{itemize}
    \item Automatic layout algorithms
    \item No decorations
    \item Different focus models
\end{itemize}

An embedded kiosk needs:
\begin{itemize}
    \item Fullscreen applications
    \item No window management at all
\end{itemize}

By leaving this out of the core, Wayland allows each compositor to implement what it needs.

\paragraph{Extensions Are Actually Optional}
In X11, despite the name, many "extensions" are effectively mandatory. Good luck running a modern desktop without RENDER, COMPOSITE, RANDR, etc.

In Wayland, the core protocol is actually sufficient for basic functionality. Extensions add features, but the core stands alone.

\subsection{The Power of Constraints}

Simplicity isn't just about having fewer features—it's about having clearer constraints:

\begin{itemize}
    \item \textbf{Easier to understand}: New developers can grasp the whole system
    \item \textbf{Easier to implement correctly}: Less code means fewer bugs
    \item \textbf{Easier to secure}: Small attack surface, clear trust boundaries
    \item \textbf{Easier to optimize}: Understand bottlenecks without drowning in complexity
\end{itemize}

\begin{examplebox}
\textbf{Analogy: Language Design}

Compare C to C++:
\begin{itemize}
    \item C: Small, simple, easy to learn fully
    \item C++: Huge, complex, nobody knows all features
\end{itemize}

Both are powerful, but C's simplicity makes it easier to reason about. Wayland aspires to be the "C" to X11's "C++"—powerful through simplicity, not feature accumulation.
\end{examplebox}

\section{Security by Architecture}

\subsection{Learning from X11's Mistakes}

X11's security problems (detailed in the previous chapter) aren't implementation bugs. They're architectural. When any client can:
\begin{itemize}
    \item Read all input
    \item Screenshot any window
    \item Inject fake events
    \item Manipulate other windows
\end{itemize}

No amount of patching fixes the fundamental problem: clients are trusted too much.

\subsection{Isolation as Default}

Wayland's philosophy: \textbf{Applications should be isolated by default. Privileges are granted explicitly.}

This means:

\paragraph{Input Isolation}
An application only receives input when it has focus. It can't see what you type in other applications. Keyloggers are impossible without compositor cooperation.

\paragraph{Visual Isolation}
An application can't read other applications' window content. Screenshots require explicit permission (granted via portals or compositor-specific mechanisms).

\paragraph{No Fake Input}
Applications can't inject synthetic keyboard or mouse events. User actions are guaranteed to be actual user actions.

\paragraph{Window Isolation}
Applications can't manipulate other applications' windows. No surprise resizes, no forced focus changes.

\subsection{The Compositor as Security Boundary}

In Wayland, the compositor is the trusted component. It mediates all interactions between:
\begin{itemize}
    \item Applications and input devices
    \item Applications and display hardware
    \item Applications and each other
\end{itemize}

This creates a clear security model:
\begin{itemize}
    \item \textbf{Trust the compositor}: It must be secure (it has all privileges)
    \item \textbf{Don't trust applications}: They're isolated and controlled
    \item \textbf{Explicit permission grants}: Privileged operations require user consent
\end{itemize}

\begin{designbox}
\textbf{Security Philosophy}

X11: "Trust all clients by default, try to add restrictions later."

Wayland: "Isolate all clients by default, grant privileges explicitly."

The second approach is fundamentally more secure. You can add privileges but you can't take them away without breaking things.
\end{designbox}

\subsection{Handling Privileged Operations}

Some legitimate use cases require privileges that break isolation:
\begin{itemize}
    \item Screen recorders need to capture all windows
    \item Remote desktop needs to inject input
    \item Accessibility tools need to see and control applications
\end{itemize}

Wayland handles this through:

\paragraph{Portal APIs}
Desktop portals provide secure, user-mediated access to privileged operations. Want to record the screen? Ask via portal, user grants permission, recording proceeds.

\paragraph{Compositor-Specific Extensions}
For trusted applications (e.g., a desktop environment's screenshot tool), compositors can provide specific extensions with appropriate safeguards.

\paragraph{Wayland Protocols}
Standardized protocols for common needs (screen copy, input method, etc.) with well-defined security boundaries.

The key: privileges are never assumed, always granted.

\section{Every Frame Is Perfect}

\subsection{The Tearing Problem}

Screen tearing—where parts of two different frames are visible simultaneously—has plagued computer graphics for decades. It happens when the display refreshes in the middle of an update.

X11 added various extensions to combat tearing (SYNC, Present), but they're bolt-on solutions fighting the architecture.

\subsection{Wayland's Guarantee}

Wayland's philosophy: \textbf{Every frame displayed should be complete and correct. No tearing.}

This is achieved through atomic buffer updates:

\begin{enumerate}
    \item Application renders a complete frame to a buffer
    \item Application sends the buffer to the compositor
    \item Compositor composites when ready
    \item Entire frame is presented atomically at next vblank
\end{enumerate}

The compositor never displays a partially-updated buffer. You see either the old frame or the new frame, never a mixture.

\begin{notebox}
This isn't just aesthetic. Tearing-free presentation is crucial for:
\begin{itemize}
    \item Professional content creation
    \item Video playback
    \item Gaming
    \item User perception of quality
\end{itemize}
\end{notebox}

\subsection{Damage Tracking}

"Perfect frames" doesn't mean redrawing everything. Wayland includes damage tracking:

\begin{itemize}
    \item Applications report which regions changed
    \item Compositor only updates changed areas
    \item Full correctness with partial update efficiency
\end{itemize}

The philosophy: optimize the common case (partial updates) without compromising correctness.

\section{Mechanism, Not Policy (Evolved)}

\subsection{X11's Interpretation}

X11 had a mantra: "Provide mechanism, not policy." The idea:
\begin{itemize}
    \item X server provides tools (mechanism)
    \item Window managers make decisions (policy)
    \item Applications and WMs negotiate via properties
\end{itemize}

This led to complex inter-client communication protocols (ICCCM, EWMH) and inconsistent behavior across different window managers.

\subsection{Wayland's Refined Approach}

Wayland keeps the spirit but refines the execution:

\paragraph{Core Provides Essential Mechanisms}
The Wayland protocol provides:
\begin{itemize}
    \item Buffer passing
    \item Input event routing
    \item Surface management
    \item Basic coordination
\end{itemize}

These are genuinely just mechanisms—they don't dictate policy.

\paragraph{Policy Is Compositor-Local}

Window management, decoration, focus handling—all policy decisions—are entirely up to the compositor. Crucially, the \textit{compositor} makes these decisions, not a negotiation between multiple parties.

This eliminates the need for complex inter-client protocols. The compositor has complete information and authority to make consistent decisions.

\paragraph{Extensions for Specific Policies}

When applications need to influence policy (e.g., "I want to be fullscreen"), standardized protocols exist. But these are \textit{requests}, not commands. The compositor can honor or deny them as it sees fit.

\begin{designbox}
\textbf{The Difference}

X11: "Here are mechanisms. Everyone negotiate policy among yourselves."

Wayland: "Here are mechanisms. The compositor decides policy. Applications can make requests."

The second approach eliminates whole classes of edge cases and race conditions.
\end{designbox}

\section{Local First, Network Second}

\subsection{Accepting Reality}

Wayland's philosophy: \textbf{Optimize for the common case: local applications on local displays.}

The vast majority of desktop applications run on the same machine as the display. Network transparency, while theoretically elegant, is:
\begin{itemize}
    \item Rarely needed in practice
    \item Costly to optimize for
    \item Better served by specialized protocols
\end{itemize}

\subsection{What This Enables}

By assuming local communication:

\paragraph{Shared Memory}
Buffers can be passed as file descriptors pointing to shared memory. Zero-copy transfer from application to compositor.

\paragraph{Direct GPU Access}
Applications can render using the GPU and pass buffer handles. No pixel copying, no context switching.

\paragraph{Asynchronous Communication}
No need for round-trip synchronization. Applications can continue working while the compositor processes buffers.

\paragraph{Simplified Protocol}
No need for network transparency means simpler protocol encoding, fewer abstractions, more direct operations.

\subsection{Network Transparency When Needed}

This doesn't mean Wayland can't do remote display:

\begin{itemize}
    \item \textbf{waypipe}: Proxies Wayland protocol over network
    \item \textbf{RDP/VNC servers}: Capture compositor output and stream
    \item \textbf{Streaming protocols}: Purpose-built for remote desktop
\end{itemize}

The difference: network support is layered on top, not baked into the foundation. This allows:
\begin{itemize}
    \item Better protocols for remote access (modern compression, adaptive quality)
    \item No performance cost for local applications
    \item Flexibility to use the right tool for the job
\end{itemize}

\section{Explicit Over Implicit}

\subsection{The Hidden State Problem}

X11 accumulated vast amounts of implicit state:
\begin{itemize}
    \item Window properties that might or might not be set
    \item Atoms with undefined semantics
    \item Extension state that interacts in undocumented ways
    \item Defaults that vary by implementation
\end{itemize}

Debugging X11 problems often involves spelunking through implicit assumptions about what state exists and what it means.

\subsection{Wayland's Explicit State}

Wayland philosophy: \textbf{Make state explicit. Make ownership clear. Make behavior predictable.}

\paragraph{Explicit Requests}
Want a surface to be fullscreen? Explicitly request it:
\begin{lstlisting}[style=cstyle]
xdg_toplevel_set_fullscreen(toplevel, output);
\end{lstlisting}

No setting properties and hoping the compositor notices.

\paragraph{Explicit Events}
When state changes, explicit events notify interested parties:
\begin{lstlisting}[style=cstyle]
// Compositor tells client about new size
void configure_handler(void *data,
                      struct xdg_toplevel *toplevel,
                      int32_t width, int32_t height,
                      struct wl_array *states) {
    // Handle resize
}
\end{lstlisting}

\paragraph{Clear Ownership}
Who owns what is explicit:
\begin{itemize}
    \item Applications own their buffers
    \item Compositor owns window positioning
    \item Input devices are managed by compositor
    \item Focus is compositor-controlled
\end{itemize}

No ambiguity about who's responsible for what.

\subsection{Benefits of Explicitness}

\begin{enumerate}
    \item \textbf{Easier debugging}: State is visible and well-defined
    \item \textbf{Better documentation}: Clear APIs with explicit semantics
    \item \textbf{Fewer bugs}: Less reliance on implicit assumptions
    \item \textbf{Predictable behavior}: Same inputs yield same outputs
\end{enumerate}

\section{Modern Graphics First}

\subsection{Designed for GPUs}

Wayland was designed from the start for GPU-accelerated rendering:

\begin{itemize}
    \item Buffer passing via DMA-BUF (GPU buffer handles)
    \item EGL integration for OpenGL/Vulkan
    \item Hardware video decode buffers
    \item Zero-copy buffer sharing
\end{itemize}

These aren't extensions or afterthoughts—they're fundamental to the design.

\subsection{Compositing as Default}

X11 added compositing through extensions. Wayland assumes compositing:

\begin{itemize}
    \item All rendering goes to off-screen buffers
    \item Compositor combines buffers with effects
    \item Atomic presentation to display
\end{itemize}

The common case (composited desktop) is the optimized path.

\subsection{Direct Scanout When Possible}

Wayland also allows the optimization: if only one fullscreen application is visible, the compositor can hand that buffer directly to the display hardware (direct scanout). Best of both worlds:
\begin{itemize}
    \item Compositing when needed (most of the time)
    \item Direct scanout when possible (fullscreen games/video)
\end{itemize}

\section{Flexibility Through Protocols}

\subsection{Core Plus Extensions}

Wayland's architecture:
\begin{itemize}
    \item Small, stable core protocol
    \item Additional protocols for specific features
    \item Compositor-specific extensions for unique needs
\end{itemize}

This provides:

\paragraph{Stability}
Core protocol rarely changes. Applications can rely on it.

\paragraph{Evolution}
New protocols add features without breaking existing applications.

\paragraph{Experimentation}
Compositors can try new ideas via custom extensions.

\paragraph{Standardization}
Successful experiments become standard protocols.

\subsection{Protocol Negotiation}

Clients discover which protocols the compositor supports:
\begin{lstlisting}[style=cstyle]
// Compositor advertises available interfaces
static void registry_global(void *data,
                           struct wl_registry *registry,
                           uint32_t name,
                           const char *interface,
                           uint32_t version) {
    if (strcmp(interface, "wl_compositor") == 0) {
        // Core protocol, always present
    } else if (strcmp(interface, "zwp_linux_dmabuf_v1") == 0) {
        // Optional extension
    }
}
\end{lstlisting}

Applications can gracefully handle missing protocols or require specific ones.

\section{Learn from History, Don't Repeat It}

\subsection{Standing on Shoulders}

Wayland's philosophy explicitly learns from X11:

\paragraph{X11 Success: Extensibility}
Wayland adopts: Multiple protocols allow evolution.

\paragraph{X11 Failure: Mandatory Extensions}
Wayland avoids: Core is self-sufficient, extensions truly optional.

\paragraph{X11 Success: Open Standards}
Wayland adopts: Openly developed, documented, and implemented.

\paragraph{X11 Failure: Trust All Clients}
Wayland avoids: Security by isolation.

\paragraph{X11 Success: Separation of Concerns}
Wayland adopts: Compositor policy vs. application rendering.

\paragraph{X11 Failure: Too Much Separation}
Wayland avoids: Don't split things that need coordination (server/compositor).

\subsection{Modern Best Practices}

Wayland incorporates modern software engineering:

\begin{itemize}
    \item \textbf{Small, focused interfaces}: Each protocol does one thing well
    \item \textbf{Type safety}: Strong typing in protocol definitions
    \item \textbf{Versioning}: Protocols can evolve compatibly
    \item \textbf{Documentation}: Generated from XML definitions
    \item \textbf{Testing}: Reference implementations and test suites
\end{itemize}

\section{Summary: The Wayland Way}

Wayland's philosophy can be distilled to key principles:

\begin{enumerate}
    \item \textbf{Recognize reality}: Compositor is the display server
    \item \textbf{Simplicity matters}: Include only what's necessary
    \item \textbf{Security by design}: Isolation first, privileges explicitly granted
    \item \textbf{Every frame perfect}: No tearing, atomic updates
    \item \textbf{Local first}: Optimize common case, support network when needed
    \item \textbf{Explicit over implicit}: Clear state, clear ownership
    \item \textbf{Modern graphics}: GPU-first, compositing-first
    \item \textbf{Flexible protocols}: Core plus extensions
    \item \textbf{Learn from history}: Keep what worked, fix what didn't
\end{enumerate}

These principles guide every design decision in Wayland. When you see something in Wayland that seems odd from an X11 perspective, these principles usually explain why.

Understanding the philosophy helps you:
\begin{itemize}
    \item Predict how Wayland will handle new situations
    \item Design better Wayland applications
    \item Contribute to protocol development
    \item Appreciate why certain trade-offs were made
\end{itemize}

Wayland isn't just "X11 done differently"—it's a fundamental rethinking based on hard-won lessons and modern requirements. The philosophy shapes the reality.

In the next chapters, we'll see how these philosophical principles manifest in concrete design decisions and technical implementations.

\clearpage
